



func {
	a: 10
	b: 20
	a + b
}

b: 5
y: func(a+b) <- change the output sequence

y = 25


func {
	a: 20
-> (a: 10)
}

Y: func.a = 20
Z: func().a = 10


module {
	a: 5
	b: 6
}

result: module(a + b) = 11







should not be able to return object, because there is no point in doing so. you are already returning a context, therefore any properties can be placed in that context
but the type facilities rely on returning a limited set of properties and checking if they exist

funct: {
	a: 10
-> {
		a: 20
	}
}

result: funct.a		// is result 10 or 20?

the result is 20, because a block with a return block shadows its properties




The statement terminator is optional when the end of a line looks like the end of a statement
(basically, if the last char on the line is an operator, or some quote or parens are open, it doesn't look like the end of a statement to the parser). This combines approaches #1 and #3.


// these lines ARE seperable, because the parser will consider these two be two seperate statement, if they are meant to be a single statement, then they should be like example 2
example1: {
	name: func

	{ 0 }
}

example2: {
	name: func {

		0
	}
}









what are the blocks of formulas called? they are really functions and the term 'block' is too vague




syntax notes, although I'd prefer to avoid line terminating chars like ';' and ',', they do make for a more flexible syntax. I'll probably have to add them eventually, so I might as well include them now


expressions are identified by use of the following symbols ':' and '->', where these symbols can only appear once on a line unless seperated by context {}()[] or an explicit terminal char ',' or ';'


// these lines are not seperable
problem: {
	name: func

	{ 0 }
}

// these lines ARE seperable
problem: {
	name: func

->	{ 0 }
}

clamp: {
	val: 0, min: 0, max: 0,

	if {
		val < min -> min;
		val > max -> max;
		else 		 -> val;
	}
};


clamp: {
	val: 0, min: 0, max: 0,

	if {
		val < min -> min,
		val > max -> max,
		else 		 -> val,
	},
},

clamp: {
	val: 0, min: 0, max: 0

	if {
		val < min | val = 90	->
			min + offset / pow(a: 2, b: 20)

		val > max | val = 88	-> 
			max + offset / pow(a: 2, b: 20)

		else -> 
			val + offset / pow(a: 2, b: 20)
	}
}

-------- ranges/slices

slices are end exclusive and indexing is 0-based, to help dispel confusion for non-computer science peoples it might be best to emphasis that an index is an offset from the start of a sequence. Thus it intuatively makes sense that the first item (0th) is at an offset of 0 from the beginning of the sequence

ranges are end-inclusive

range: [1..10]		1,2,3,4,5,6,7,8,9,10
slice: [0|10]		0,1,2,3,4,5,6,7,8,9
slice: [0:10]		0,1,2,3,4,5,6,7,8,9




-------- static typing

Option: {
	None: {}
	Some: { a: 0 }
}


-- Match
bob: { Some: { a: 10 } }

result: bob? (
	None		-> 0
	Some (a)	-> a
)


x: [1,2,3] ? (A[a, b, c] -> A)


bob: chars.next? (
	Some (digit: '0'..'9') -> digit
)



-- RustLike Exception Handling


-- copy just a few properties

group: { a: 1, b: 2, c: 3 }
some: group.{ a, b } 

some: group.{ a b } 





add: (a: 0, b: 0 -> b + a)

add: { a: 0, b: 0 -> b + a }

add: { a: 0 b: 0 b + a }	// -> and , should be optional








all operations are are defined by structured graphs
each node has a value and a namespace (except infix operators)
unlike other languages, function inputs are unordered and named

properties of called graphs are not inherited by callee, unless explicitly specified


-------- static typing
name : u32 = 10


--------- operators and their precedence
() [] {}
. []
+ -		unary plus and minus
~ 			negate
* / %


= pattern and or type
: assignment

--------- conditionals
if [

]

clamp = {
	val = 0
	min = 0
	max = 0
->	if [
		val < min -> min,
		val > max -> max,
		else		 -> val,
	]
}


bin = {
	a = 0, b = 0
-> match a b [
		0 0 | 0 1 -> 0,
		1 0 | 1 1 -> 1,
		a b | if a > b -> a,
		_ _ -> -1
	]
}




--------- destructuring and types and constraints


colors: type {
	red, orange, yellow, green, blue
}




array[a, b, c] = [1, 2, 3]
array[a[a1, a2], b[b1, b2]] = [[1, 2], [3, 4], [5, 6]]

array[a[a1, a2], b[b1, b2]]: [[1, 2], [3, 4], [5, 6]]


match array [
	[a, b] -> a + b,
	______ -> panic,
]


--------- array indexing

myArray = [1,2,3,4,5]
slice = myArray[1:3]

slice: myArray.property[1..]


--------- property access

bob = {
	child = {
		name = "jill"
	}
}
bobs_kid = bob.child.name




when using a {graph} instead of a single expression -> indicates the returned expression of graph


simple_expression = 1 + 2
complex_expression = {
	a = 1
	b = 2
-> a + b
}
subexpressions of a complex expression can be accessed with '.'

bob = complex_expression.b




quad = {
	a = 0, b = 0, c = 0,
	discriminant = b^2 - 4*a*c
	squared = sqrt{ x = discriminant }
	denominator = 2*a

->	(-b - squared) / denominator
}


result = {
	b = 10 + 9/2
->	quad { a = 1, b, c = 3 }
}


xs = [1,2,3]
sum = fold { xs, i = 0,				
	operator = {
		a = 0
		b = 0
	->	a + b
	}
}


myArray = [1,2,3]
sum = fold {	xs = myArray, i = 0,
	operator = {
		a = 0
		b = 0
	->	a + b
	}
}

myArray: [1,2,3]
sum: fold {	xs: myArray, i: 0,
	operator: {
		a: 0
		b: 0
	->	a + b
	}
}





Y: 4 * 2 + (9 - 5)

add: { a: 1, b: 2 -> a + b }
sub: { a: 1, b: 2 -> a - b }
mul: { a: 1, b: 2 -> a * b }


Y: add {
	a: mul { a: 4, b: 2 }
	b: sub { a: 9, b: 5 }
}

Y => 12

Y.a => 8
Y.b => 4

y.a.a => 4
y.a.b => 2
y.b.a => 9
y.b.b => 5


























sum = fold (xs, 0) {

}





























J would be cleaner if you could defined operators with multiple chars and delimit them with whitespace like forth

this also allows for reading from left to right as a user would expect.
adverbs will usually be binary or prefix, because they need to capture a verb before it tries to execute


	| fold
	$ scan

	1 2 3 4 5 | +
15

	sum <- | +
	1 2 3 4 5 sum
15

boxes in J
   b =: (< 1) , (< 'hello')
   b
┌─┬─────┐
│1│hello│
└─┴─────┘
   # b
2


	b <- #[1], #['hello']
	b
[#[1] #['hello']]

	b len


addTwo <- 2 +
result <- 1 2 3 4 5 addTwo
	=> 3 4 5 6 7

undoAddTwo <- -1 :^ addTwo





the only reason such operations work so well in APL is that it executes in a reverse stack and operators are divided into two categories 'verbs' and 'adverbs' 
verbs being operators that operate on nouns and adverbs being operators that operate on verbs.
















the false stack language, what if instead of thinking in terms of a stack, the user thinks in terms of a hole.
for example the function 'add', when placed in the 'hole' causes the hole to get two elements deeper, thus, you will need two items to fill the area of that hole


func = add  3   5	-> 8
		 ^^^ ^^^ ^^^
  hole [2] [1] [0]  [1]

this is not composable, becaue elements still accumulate on the left, out of reach of the next prefix operator to come along

the only reason such operations work so well in APL is that it executes in a reverse stack and operators are divided into two categories 'verbs' and 'adverbs' 
verbs being operators that operate on nouns and adverbs being operators that operate on verbs.








: apply
| param



quadratic = {
-- a b c

	dis = b b * 4 a * c * -
	sqr = dis Sqrt
	den = 2 a *

-> b ~ sqr - den /
-> b ~ sqr + den /
}


sum = [100 iota] 0 Fold { -- a b -> a b + }
sum = [100 iota] 0 Fold (a b -> a b +)
sum = [100 iota] 0 Fold (+)

inc = [100 iota] (a -> a 1 +) Each
inc = [100 iota] (1 +) Each


sum [100 iota] 0 (
-- a b c

	dis = b b * 4 a * c * -
	sqr = dis Sqrt
	den = 2 a *

-> b ~ sqr - den /
-> b ~ sqr + den /
)	Fold



// this:
quad-result = 1 5 3 (
-- a b c

	dis = b b * 4 a * c * -
	sqr = dis Sqrt
	den = 2 a *

-> b ~ sqr - den /
-> b ~ sqr + den /
)	do

// is the same as
// this
quad-result = 1 5 3 {
-- a b c

	dis = b b * 4 a * c * -
	sqr = dis Sqrt
	den = 2 a *

-> b ~ sqr - den /
-> b ~ sqr + den /
}
















solve2 = {
<-	(a, b, c)

	dis = b^2 - 4*a*c
	sqr = Sqrt dis
	den = 2 * a

->	(~b + sqr) / den, (~b - sqr) / den
}



clamp = {
	<- val min max

	if val > max	-> operation max + offset;
		val < min	-> operation min - offset;
		else			-> operation val / divsor;
}


Fold [1 .. 100] 0 {
	<- (dilation, radius)
	<- segment

		x = a + b
		y = b + a

	-> x + y
}

Fold.Left
	(array = [1 .. 100])
	(start = 0) {
		<- (dilation, radius)
		<- segment

			x = a + b
			y = b + a

		-> x + y
	}



Bin = {
<- a b
of	0 0 -> toString 0;
	0 1 -> toString 1;
	1 0 -> toString 2;
	1 1 -> toString 3;
	_ _ -> toString 4;
}

bin = {
<- input
	x = input * 2
	y = input + 9

-> match	compare(input) {
		GT -> "greater than";
		EQ -> "equal to";
		LT -> "less than";
	}
}


message = {
is maybe_digit
of	Some x if x < 10 -> process_digit x;
	Some x -> process_other x;
	None -> panic "oh no";
}















fun solve2 (a : real, b : real, c : real) =
    let val discr  = b * b - 4.0 * a * c
        val sqr = Math.sqrt discr
        val denom = 2.0 * a
    in ((~b + sqr) / denom,
        (~b - sqr) / denom)
    end


solve2 = {
<-	(a, b, c)
<-	input

	dis = b^2 - 4*a*c
	sqr = Sqrt dis
	den = 2 * a

->	(~b + sqr) / den,
   (~b - sqr) / den
}

result = solve2 (1, 5, 3)


solve1 = (a, b, c) <>
	(~b + Sqrt(b*b - 4*a*c)) / (2*a),
   (~b - Sqrt(b*b - 4*a*c)) / (2*a)






quad = (a, b, c): sqrt (b^2 - 4*a*c)
	->	dis:
		((~b - dis) / (2*a), (~b + dis) / (2*a))
	->	(a, b):
		a + b - dis


10:inc

intAdd = (i32 a) (i32 b) -> a + b

intAdd = fn (a:i32) (b:i32) {a + b}


quad =
		fn (a, b, c) {
			sqrt (b^2 - 4*a*c)
	→	fn dis {
			((~b - dis) / (2*a), (~b + dis) / (2*a))
	→	fn (a, b) {
			a + b - dis
	}}}

quadratic =	(a, b, c) ->
			sqrt (b^2 - 4*a*c)
	|>	dis ->
			((~b - dis) / (2*a), (~b + dis) / (2*a))
	|>	(a, b) ->
			a + b - dis


quad = a b c -> {
	dis = sqrt (b^2 - 4*a*c);
	pos = (~b - dis) / (2*a);
	neg = (~b + dis) / (2*a);
	
	pos + neg - dis
}


sum = [1,2,3,4] : Fold 0 ((a, b) -> a + b)

sum = [1,2,3,4] -> Fold 0 (-> (a, b) : a + b)



max = if {
	a > b: a
	else: b
}

bin => a b ? {
	0 0: 0
	0 1: 1
	1 0: 2
	1 1: 3
}

bin = a b -> a ? {
	0 => b ? {
		0 => 0
		1 => 1
	}
	1 => b ? {
		0 => 2
		1 => 3
	}
}

bin = x -> x ? {
	(0, 0) => 0
	(0, 1) => 1
	(1, 0) => 2
	(1, 1) => 3
}

max = a b -> if {
	a > b	=> a,
	else	=> b,
}



message = maybe_digit ? {
	(Some x) if x < 10 =>
		process_digit x

	(Some x) =>
		process_other(x)

	None =>
		panic("Invalid operation")
}




message = maybe_digit ? {
=>	(Some x) | x < 10:
		process_digit x

=>	(Some x):
		process_other(x)

=> None:
		panic("Invalid operation")
}






bob = (1, 2) -> (a, b) ? {
	
}

bob = (1, 2) : (a, b) ? {
	
}

Y = 10 + 20 : k -> k * 3
Y = 10 + 20 : (k -> k * 3)


bob = x : (a, b) ? {
	(1, 2) ->
	______ -> 
}


bob = 10 : inc





binary = a b -> ? {
	0 0 : 0 
	0 1 : 1
}


Z =  {
	if a > b: GT
	if a = b: EQ
	else:		 LT
}

Z = 10 + if {

}



max => a b : if {
	a > b: a
	else:  b
}


max = a b -> if {
	a > b: a
	else:  b
}





message = maybe_digit ? {
	(Some x) | x < 10:
		process_digit x

	(Some x):
		process_other(x)

	None:
		panic("Invalid operation")
};



operate =
->	(first, second, operator): -> operator ? {
		'+' = first + second
		'-' = first - second

		'*' | 'x' | 'X'
			 = first * second

		'/' = first / second
		 _  = panic "Invalid operator used."
	}
->	result: round(result, 2)


binary =
-> a b :	(a, b) ? {
	(0, 0) = 0
	(0, 1) = 1
	(1, 0) = 2
	(1, 1) = 3
}

binary => a b ? {
	0 0 = 0
	0 1 = 1
	1 0 = 2
	1 1 | a b = 3
}

binary => a: -> b: 


10 + ?{if a > b: 10, else: 4}

10 + ?(a > b: 10, else: 4)

10 + (if a > b then 10 else 4)


10 + (a > b? 10, else? 4)


max => a b ? {
	if a > b: a
	else: b
}

OutOfRange => a lower upper ? {
	if a < lower | a > upper:
		"out of bounds"

	else:
		"all good"
}


message = maybe_digit ? {
	(Some x) if x < 10:
		process_digit x

	(Some x):
		process_other(x)

	None:
		panic("Invalid operation")
};




add => a -> b : a + b

inc = add 1
two = inc 1

add => (a, b): a + b

inc => b: add(1, b)
ten = inc 9



add = -> x : x + x;
given x then add x to x

-> given pattern
:  continue
?	match

Fold (-> a b : a + b) [1,2,3,4,5]






quad =
-> (a, b, c):
	sqrt (b^2 - 4*a*c)
->	dis:
	((~b - dis) / (2*a), (~b + dis) / (2*a))
->	(a, b):
	a + b - dis



Math {
	add = (a, b): a + b
	sub = (a, b): a - b
}

integer = 10|s32


Quad {
->	(a, b, c):
	dis = sqrt (b^2 - 4*a*c)
	neg = (~b - dis) / (2*a)
	pos = (~b + dis) / (2*a)
}

result = Quad(1, 5, 3) -> res: [res.neg, res.pos]


sum = fold (
	xs = [1,2,3,4]
	fn = (a, b): a + b
)


[1,2,3,4,5] -> xs: map(xs, x: x + 1) | [i32]








quad {
-> (a, b, c):
	sqrt (b^2 - 4*a*c)
-> dis:
	((~b - dis) / (2*a), (~b + dis) / (2*a))
-> (a, b):
	a + b - dis
}


Math {
	add {-> (a, b): a + b }
	sub {-> (a, b): a - b }
}

Math {
	add => (a, b): a + b
	sub => (a, b): a - b
}


Quad {
-> (a, b, c)
	dis { sqrt (b^2 - 4*a*c) }
	neg { (~b - dis) / (2*a) }
	pos { (~b + dis) / (2*a) }
}

Quad {
-> (a, b, c)
	dis = sqrt (b^2 - 4*a*c)
	neg = (~b - dis) / (2*a)
	pos = (~b + dis) / (2*a)
}

result = Quad(1, 5, 3) -> res: [res.neg, res.pos]


















sum = fold (
	xs = [1,2,3,4]
	fn => (a, b): a + b
)


	id = x | x
	id x = x 

operation (|a,b| a + b)
operation ((a,b) -> x + x)
operation ((a,b) | x + x)
operation (-> (a,b): x + x)


quad => (a, b, c) : sqrt (b^2 - 4*a*c) -> dis: ((~b - dis) / (2*a), (~b + dis) / (2*a))

quad =
-> (a, b, c):
	sqrt (b^2 - 4*a*c)
-> dis:
	((~b - dis) / (2*a), (~b + dis) / (2*a))
-> (a, b):
	a + b - dis


result = quad (1, 5, 3) => (a, b) : a^2 - b*4

add = |(a,b), fn| fn(a, b)

add((a, b), fn) = fn(a, b)

add = ((a, b), fn) | fn(a, b)


hmm = (a, b) | a * b => c : c + 3 * b

add = (a b -> a + b)

result {
	add = (a, b) -> a + b
	mul = (a, b) -> a * b
	
	(add(5, 10), mul(78, 20)) => (a, b) : a - b
}


add = a b ->
	a + b,
	mul = (a b -> a * b)


need way to define values and sequences

structs

jeff = expression
jeff : sequence


result = {
	add(a; b) = a + b;
	mul(a; b) = a * b;

		add(5; 10),
		mul(78, 20),
	a b -> a - b
}

result(a; b) =


add(
	{ 10, 20, (+) },
	{ 30, 40, (*) }
)


Some_Function (
	a = { 10, 20, (+) },
	b = { 30, 40, (*) }
)

{ sequence }
( parenthe )
[ homorray ]





code = some input

node = signal ? code match-{
	0 => "OK" Print
	1 => "Wires Tangled" Print
	2 => "User Asleep" Print
	_ => "Unrecognized Error {}" [code] Format Print
}


code = some input

node = signal ? code match-{
	0 = "OK"
	1 = "Wires Tangled"
	2 = "User Asleep"
	_ = ("Unrecognized Error {}" [code] Format)
}	
	Print




let output = File::create(filename)?;

let output = match File::create(filename) {
	Ok(f) => f,
	Err(err) => return Err(err)
}


output = filename File.create match-{
	(f Ok)  => f
	(e Err) =>  
}



let is_even = |x: u64| -> bool x % 2 == 0; // error
let is_even = |x: u64| -> bool { x % 2 == 0 }; // ok


is_even = x -> x % 2 == 0

is_even = x -> x 2 (%) 0 (==)